%----------------------------------------------------------------------% M. Sayles. Purdue (November, 2014). Modified from tc.m.%----------------------------------------------------------------------%Implements a set of functions for inhibition/suppresion/masking%experiments:%%--------------------------------------------------------------------%Analysis Types: (1-6):%---------------------------------------------------------------------%1. "Suppression Threshold as a function of frequency". [Tracks lower%threshold boundary of two-tone suppression / neural inhibition as a%function of frequency around CF. Probe tone fixed - typically at CF].%---------------------------------------------------------------------%2. "Growth of Suppression". [For a fixed probe tone (typically at CF)%measures the attenuation required at the probe to achieve a criterion%discharge rate, as a function of suppressor frequency and level - i.e.,%rate of growth of suppression (dB/dB) as a function of frequency around%CF].%---------------------------------------------------------------------%3. "Growth of Adaptation". [Similar to #2 above. This measures the%contribution of neural adaptation to these growth functions - acts as a%correction factor for #2 - see Delgutte (1990a)].%---------------------------------------------------------------------%4. "Forward Masking". [For a fixed masker frequency (default is 1 kHz) at%a fixed level (default is 85dBSPL), measures the amount of forward masking%as a function of frequency. Effectively this just measures an excitatory%tuning curve for the unit in the presence of a (forward) masker].%See Delgutte (1990b).%---------------------------------------------------------------------%5. "Simultaneous Masking". [For a fixed masker frequency (default is 1 kHz) at%a fixed level (default is 85dBSPL), measures the amount of simultaneous masking%as a function of frequency. Effectively this just measures an excitatory%tuning curve for the unit in the presence of a (simultaneous) masker].%Comparison of #4 and #5 allows us to figure out the relative contribution%of suppression and adaptation to masking patterns.%See Delgutte (1990b).%---------------------------------------------------------------------%6. "Recovery from Masking". [Measures threshold for a CF tone as a%function of time interval between two successive tones. This allows us to%quantify the time course of recovery from forward masking].%See Bleeck et al. (Hear Res 2006).%---------------------------------------------------------------------%%****Note to user*****!!!! It is important to have measured a normal tuning curve%%AND a CF-tone input-output function for a unit before using this program%%if you want to make full use of its functions.%---------------------------------------------------------------------%References:%Delgutte (1990a). Two-tone rate suppression in auditory-nerve fibers:%Dependence on suppressor frequency and level. Hear Res. 49: 225-246.%Delgutte (1990b). Physiological mechanisms of psychophysical masking:%Observations from auditory-nerve fibers. JASA. 87(2): 791-809.%Bleeck, Sayles, Ingham, Winter (2006). The time course of recovery from%suppression and facilitation from single units in the mammalian cochlear%nucleus. Hear Res. 212: 176-184.%-----------------------------------------------------------------------global root_dir NelDatafilename = current_data_file('inhibit');Channel = 1;AnalysisType = PARAMS(17);%Switches between the 6 analysis options listed aboveGatelength = 1;%ONLY used for recovery from masking experiment. Set cos2 gate to 1-ms!!! Otherwise it defaults to 5ms.switch AnalysisTypecase {1,4,5}    frqlo = PARAMS(1);%Upper and lower frequency bounds on tuning-curve type analyses (suppression curve, forward-masked TC, simult masked TC)    frqhi = PARAMS(2);case 6 %Special case - just one frequency, but varying inter-stimulus interval    frqlo = PARAMS(1); %Dummy for axes    frqhi = PARAMS(2); %Dummy for axes    deltaTlo = PARAMS(28);%Minimum inter-stimulus interval    deltaThi = PARAMS(29);%Maximum inter-stimulus interval    deltaTstep = PARAMS(30);    Toctaves = log2(deltaThi/deltaTlo);    deltaT = deltaTlo.*2.^(0:deltaTstep:Toctaves);%Vector of inter-tone intervals (ms)otherwise %Suppression and adaptation growth functions (analyses 2 and 3)    frqlo = PARAMS(18);%upper and lower frequencies to consider for the suppressors for the growth functions    frqhi = PARAMS(19);endlinstps = PARAMS(3);logstps = PARAMS(4);unitCF = current_unit_bf;unitThresh = current_unit_thresh;ToneOn  = PARAMS(11);% tone on duration (ms)ToneOff = PARAMS(12);% tone off duration (ms)tspan = (ToneOn+ToneOff)/1000;%one on-off period (in seconds!!!!)tspan_ms = tspan*1000;%one on-off period (ms)attlo  = PARAMS(5);attstp = PARAMS(7);atthi  = PARAMS(6);if AnalysisType ==6    atten = current_unit_thresh; %In this case we already have a pretty good idea of threshold - so start there    maxlength = (ToneOn*2)+(deltaThi*2);else        atten  = attlo; %The algorithm will start with a low atten (high SPL) for the suppressor on the high-frequency side of CF%     atten = atthi;endRespWin1= PARAMS(13)/1000; %start of A interval... ALL in secondsRespWin2= PARAMS(14)/1000; %end of A intervalRespWin3 = RespWin1+tspan; %start of B intervalRespWin4 = RespWin2+tspan; %end of B intervalCFAtten = PARAMS(15);CFFreq = PARAMS(16);switch AnalysisTypecase 1    octaveslo = log2(CFFreq/frqlo);    octaveshi = log2(frqhi/CFFreq);case {4,5}    octaves = log2(frqhi/frqlo);otherwise    octaves = PARAMS(20);endif AnalysisType==4 | AnalysisType==5    MaskerF = PARAMS(25);    MaskerL = PARAMS(26);    calibPic = PARAMS(27);    currdir = cd;    cd (NelData.File_Manager.dirname);    calib = loadPic(calibPic);    cd (currdir);    maxSPL = CalibInterp(MaskerF,calib.CalibData(:,[1,2]));    Masker_att = round(maxSPL-MaskerL);    if Masker_att<attlo        Masker_att = attlo;        ding;        warning('Attempted to set masker to < low atten!!! Defaulted to low atten.');    endendear = PARAMS(10);left  = 1;right = 2;handles = get(gcf,'Userdata');h_ax1   = handles(8);if (ishandle(h_ax1))    delete(h_ax1);endh_ax1 = axes('position',[.1 .415-0.08 .8 .56+0.08]);handles(8) = h_ax1;set(gcf,'Userdata',handles);h_line1 = semilogx(50,0,'r-','LineWidth',2,'EraseMode','none');hold on;h_line2 = plot(50,0,'wo','MarkerSize',6,'EraseMode','xor');h_line3 = plot(50,0,'yx','MarkerSize',12,'EraseMode','xor');axis([frqlo frqhi -atthi-5 -attlo+5]);set(h_ax1,'XTick',[frqlo+.000001 frqhi],'TickDir','out');set(h_ax1, 'XTick', ...    unique(min(frqhi,max(frqlo, [frqlo+.000001 0.1 0.2 0.4 1 2 4 7 10 15 20:10:50 100 frqhi]))));set(h_ax1, 'XMinorTick', 'off');set(h_ax1,'YTick',[-120:20:0]);xlabel('Frequency (kHz)','fontsize',14);ylabel('Attenuation (dB)','fontsize',14);set(h_ax1,'Color',[0.3 0.3 0.3]);drawnow;match2    = PARAMS(8);switch AnalysisTypecase 1    %For suppression tuning curve criterion for adaptive tracking is    %difference betwen A and B intervals (typically set to 0)    crit = PARAMS(9);    Satten_lst = 0; %Dummy for the tuning curve case        if logstps > 0,        frqlst=[logspace(log10(frqhi),log10(CFFreq),octaveshi*logstps) logspace(log10(frqlo),log10(CFFreq),octaveslo*logstps)];    elseif logstps < 0,        frqlst=[Qspace_inhibit(frqhi,CFFreq,-logstps) Qspace_inhibit(frqlo,CFFreq,-logstps)];    else        frqlst=[linspace(frqhi,CFFreq,octaveshi*linstps) linspace(frqlo,CFFreq,octaveslo*linstps)];    endcase {4,5,6}    crit = PARAMS(9);    Satten_lst = 0; %Dummy        if logstps > 0,        frqlst=logspace(log10(frqhi),log10(frqlo),octaves*logstps);    elseif logstps < 0,        frqlst=Qspace_inhibit(frqhi,frqlo,-logstps);    else        frqlst=linspace(frqhi,frqlo,octaves*linstps);    endotherwise    %For suppression growth / adaptation growth functions, criterion is the spike-rate (sp/s) to track - set to 2/3 up IOFN to CF tone - default value is 100 sp/s    SpikeRateCrit = PARAMS(24); %For suppression growth / adaptation growth functions, criterion is the spike-rate (sp/s) to track - set to 2/3 up IOFN to CF tone - default value is 100 sp/s    crit = 0;%Needed to compare SpikeRateCrit to the driven spike rate    maxSatten = PARAMS(22);    stepSatten = PARAMS(23);    Satten_lst = maxSatten:-stepSatten:attlo; %list of attenuation settings for the suppressor (adaptor) at which to track CF threshold against criterion for growth functions        if octaves        frqlst = [logspace(log10(frqhi),log10(CFFreq*2^octaves),log2(frqhi/CFFreq*2^octaves)/octaves) logspace(log10(frqlo),log10(CFFreq*2^-octaves),log2((CFFreq*2^-octaves)/frqlo)/octaves)];    else        frqlst = PARAMS(21);    end    frqlst = frqlst(randperm(length(frqlst)));endswitch AnalysisTypecase 6    frqnum = length(deltaT);otherwise    frqnum = length(frqlst);endSattennum = length(Satten_lst);Satten = Satten_lst(1);%Find the optimal initial select, connect, and atten settingsswitch AnalysisTypecase 1    [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN CFAtten NaN atten NaN]' [NaN NaN NaN NaN NaN CFAtten NaN atten NaN]']);case {2,3}    [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN Satten NaN atten NaN]' [NaN NaN NaN NaN NaN Satten NaN atten NaN]']);case {4,5}    [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN Masker_att NaN atten NaN]' [NaN NaN NaN NaN NaN Masker_att NaN atten NaN]']);case 6    [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN CFAtten NaN atten NaN]' [NaN NaN NaN NaN NaN CFAtten NaN atten NaN]']);endswitch earcase 1    connect = [connect(1) 0];case 2    connect = [0 connect(2)];endconfig(1) = struct('atten',[1 0],'sel',select,'conn',[connect(1) 0]); %left ear select codeconfig(2) = struct('atten',[0 1],'sel',select,'conn',[0 connect(2)]); %right ear select codeconfig(3) = struct('atten',[1 1],'sel',select,'conn',connect); %both ears selected%Make inhibitdata structureswitch AnalysisTypecase {1,4,5,6}    inhibitdata.PEST = zeros(frqnum,2);otherwise%cases 2 and 3, also save the attenuation of the suppressor!    inhibitdata.PEST = zeros(frqnum,Sattennum,3);endinhibitdata.spikerate = [];%Save the computed spike rate data for an idiot checkinhibitdata.spiketimes = [];%Was going to try saving spike times.... but% might not be fast enoughsearch = 'on';%Set up RP2.1 #1rc = 1;RPco1=actxcontrol('RPco.x',[0 0 1 1]);rc = rc & invoke(RPco1,'Connect',4,1);switch AnalysisTypecase 6    rc = rc & invoke(RPco1,'LoadCof',[root_dir 'inhibit\object\tc_left_npulse_delay_mode6.rcx']);otherwise    rc = rc & invoke(RPco1,'LoadCof',[root_dir 'inhibit\object\tc_left_npulse_delay.rcx']);endrc = rc & invoke(RPco1,'SetTagVal','Select_L',select(1));rc = rc & invoke(RPco1,'SetTagVal','Connect_L',connect(1));rc = rc & invoke(RPco1,'SetTagVal','StmOn',ToneOn);switch AnalysisTypecase {3,4}    rc = rc & invoke(RPco1,'SetTagVal','StmOff',tspan_ms+ToneOff);case 6    rc = rc & invoke(RPco1,'SetTagVal','StmOff',ToneOff);otherwise    rc = rc & invoke(RPco1,'SetTagVal','StmOff',ToneOff);endswitch AnalysisTypecase {1,2,5}    rc = rc & invoke(RPco1,'SetTagVal','NumPulse',20);case {3,4}    rc = rc & invoke(RPco1,'SetTagVal','NumPulse',10);case 6    rc = rc & invoke(RPco1,'SetTagVal','NumPulse',1);endrc = rc & invoke(RPco1,'Run');if (rc ~= 1)    nelerror('inhibit.m: can''t load tc_left to RP #1');end%Set up RP2.1 #2rc = 1;RPco2=actxcontrol('RPco.x',[0 0 1 1]);rc = rc & invoke(RPco2,'Connect',4,2);switch AnalysisTypecase 6    rc = rc & invoke(RPco2,'LoadCof',[root_dir 'inhibit\object\tc_left_npulse_delay_slave_mode6.rcx']);case 1    rc = rc & invoke(RPco2,'LoadCof',[root_dir 'inhibit\object\tc_left_npulse_delay_slave_mode1.rcx']);otherwise    rc = rc & invoke(RPco2,'LoadCof',[root_dir 'inhibit\object\tc_left_npulse_delay_slave.rcx']);endrc = rc & invoke(RPco2,'SetTagVal','Select_L',select(2));rc = rc & invoke(RPco2,'SetTagVal','Connect_L',connect(2));rc = rc & invoke(RPco2,'SetTagVal','StmOn',ToneOn);switch AnalysisTypecase {1,2,3,4,5}    rc = rc & invoke(RPco2,'SetTagVal','StmOff',(ToneOff*2)+ToneOn);    rc = rc & invoke(RPco2,'SetTagVal','NumPulse',10);otherwise    rc = rc & invoke(RPco2,'SetTagVal','StmOff',ToneOff);    rc = rc & invoke(RPco2,'SetTagVal','NumPulse',1);endswitch AnalysisTypecase 6    rc = rc & invoke(RPco2,'SetTagVal','PulseDelay',double((ToneOn)+(Gatelength/1.6)+deltaT(1)));case {2,3,4,5}    rc = rc & invoke(RPco2,'SetTagVal','PulseDelay',double((tspan_ms)));endrc = rc & invoke(RPco2,'Run');if (rc ~= 1)    nelerror('inhibit.m: can''t load tc_left to RP #2');end%Set all PA5 attenuators to 120 dBPAco1=actxcontrol('PA5.x',[0 0 1 1]);for atten_num = 1:4,    invoke(PAco1,'Connect',4,atten_num);    invoke(PAco1,'SetAtten',120.0);end%This is setting the attenuation on each of the PA5 modules 1-4if config(ear).atten(left),    invoke(PAco1,'Connect',4,1);    invoke(PAco1,'SetAtten',PAattns(1));    invoke(PAco1,'Connect',4,2);    invoke(PAco1,'SetAtten',PAattns(2));    invoke(PAco1,'Connect',4,3);    invoke(PAco1,'SetAtten',PAattns(3));else    invoke(PAco1,'Connect',4,3);    invoke(PAco1,'SetAtten',120.0);endif config(ear).atten(right),    invoke(PAco1,'Connect',4,1);    invoke(PAco1,'SetAtten',PAattns(1));    invoke(PAco1,'Connect',4,2);    invoke(PAco1,'SetAtten',PAattns(2));    invoke(PAco1,'Connect',4,4);    invoke(PAco1,'SetAtten',PAattns(4));else    invoke(PAco1,'Connect',4,4);    invoke(PAco1,'SetAtten',120.0);endswitch AnalysisTypecase 1    invoke(RPco1,'SetTagVal','Freq',CFFreq*1000);    invoke(RPco2,'SetTagVal','Freq',frqlst(1)*1000);case {2,3}    invoke(RPco1,'SetTagVal','Freq',frqlst(1)*1000);    invoke(RPco2,'SetTagVal','Freq',CFFreq*1000);case {4,5}    invoke(RPco1,'SetTagVal','Freq',MaskerF*1000);    invoke(RPco2,'SetTagVal','Freq',frqlst(1)*1000);case 6    invoke(RPco1,'SetTagVal','Freq',CFFreq*1000);    invoke(RPco2,'SetTagVal','Freq',CFFreq*1000);endFrun=1;while Frun <= frqnum,    if get(h_push_stop,'Userdata'), break; end    for Lrun =1:Sattennum,        new_freq_lev = 0;        %% Allow doubling or halving of freqstep size if collecting a suppression tuning curve        if get(h_push_d_fstep,'Userdata') & (AnalysisType==1 | AnalysisType==4 | AnalysisType==5),            switch (get(h_push_d_fstep,'Userdata'))            case 'double'                fact=2.0;            case 'halve'                fact=0.5;            end            set(h_push_d_fstep,'Userdata',[])            switch AnalysisType            case 1                if frqlst(Frun-1)>CFFreq                    octaveshi = log2(frqlst(Frun-1)/CFFreq);                    octaveslo = log2(CFFreq/frqlo);                else                    octaveslo = log2(CFFreq/frqlst(Frun-1));                end                if logstps > 0,%Done                    logstps=round(logstps*fact);                    if frqlst(Frun-1)>CFFreq                        newfrqlst=[logspace(log10(frqlst(Frun-1)),log10(CFFreq),octaveshi*logstps) logspace(log10(frqlo),log10(CFFreq),octaveslo*logstps)];                    else                        newfrqlst=logspace(log10(frqlst(Frun-1)),log10(CFFreq),octaveslo*logstps);                    end                    log_txt='yes'; step_txt=logstps;                elseif logstps < 0,%Done                    logstps=round(logstps*fact);                    if frqlst(Frun-1)>CFFreq                        newfrqlst=[Qspace_inhibit(frqlst(Frun-1),CFFreq,-logstps) Qspace_inhibit(frqlo,CFFreq,-logstps)];                    else                        newfrqlst=Qspace_inhibit(frqlst(Frun-1),CFFreq,-logstps);                    end                    log_txt='Q'; step_txt=abs(logstps);                else%Done                    linstps=round(linstps*fact);                    if frqlst(Frun-1)>CFFreq                        newfrqlst=[linspace(frqlst(Frun-1),CFFreq,octaveshi*linstps) linspace(frqlo,CFFreq,octaveslo*linstps)];                    else                        newfrqlst=linspace(frqlst(Frun-1),CFFreq,octaveslo*linstps);                    end                    log_txt='no'; step_txt=linstps;                end            case {4,5}                octaves = log2(frqlst(Frun-1)/frqlo);                if logstps > 0,%Done                    logstps=round(logstps*fact);                    newfrqlst=logspace(log10(frqlst(Frun-1)),log10(frqlo),octaves*logstps);                    log_txt='yes'; step_txt=logstps;                elseif logstps < 0,%Done                    logstps=round(logstps*fact);                    newfrqlst=Qspace_inhibit(frqlst(Frun-1),frqlo,-logstps);                    log_txt='Q'; step_txt=abs(logstps);                else%Done                    linstps=round(linstps*fact);                    newfrqlst=linspace(frqlst(Frun-1),frqlo,octaves*linstps);                    log_txt='no'; step_txt=linstps;                end            end            if(length(newfrqlst)>1)                frqlst=[frqlst(1:Frun-1) newfrqlst(2:end)];            end            frqnum = length(frqlst);            set(h_text4b,'String',{step_txt; ' '; log_txt})        end        if AnalysisType==2 | AnalysisType==3            Satten = Satten_lst(Lrun);        end        freq = frqlst(Frun);        level_stk = zeros(1,9);        switch AnalysisType        case {1,4,5}            invoke(RPco2,'SetTagVal','Freq',freq*1000);        case {2,3}            invoke(RPco1,'SetTagVal','Freq',freq*1000);        case 6            invoke(RPco2,'SetTagVal','PulseDelay',(ToneOn)+deltaT(Frun)+Gatelength/1.6);        end        while isempty(get(h_push_stop,'Userdata')),  		%check for stop here            msdl(1,Channel);            %             ARatenow = 0;            %             BRatenow = 0;            switch AnalysisType            case 1                [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN CFAtten NaN atten NaN]' [NaN NaN NaN NaN NaN CFAtten NaN atten NaN]']);            case {2,3}                [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN Satten NaN atten NaN]' [NaN NaN NaN NaN NaN Satten NaN atten NaN]']);            case {4,5}                [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN Masker_att NaN atten NaN]' [NaN NaN NaN NaN NaN Masker_att NaN atten NaN]']);            case 6                [select,connect,PAattns] = find_mix_settings([[NaN NaN NaN NaN NaN CFAtten NaN atten NaN]' [NaN NaN NaN NaN NaN CFAtten NaN atten NaN]']);            end            switch ear            case 1                connect = [connect(1) 0];            case 2                connect = [0 connect(2)];                %otherwise if both ears selected (ear=3) then just keep                %the original connect values from find_mix_settings                %output            end            rc = rc & invoke(RPco1,'SetTagVal','Select_L',select(1));            rc = rc & invoke(RPco1,'SetTagVal','Connect_L',connect(1));            rc = rc & invoke(RPco2,'SetTagVal','Select_L',select(2));            rc = rc & invoke(RPco2,'SetTagVal','Connect_L',connect(2));            if config(ear).atten(left),                invoke(PAco1,'Connect',4,1);                invoke(PAco1,'SetAtten',PAattns(1));                invoke(PAco1,'Connect',4,2);                invoke(PAco1,'SetAtten',PAattns(2));                invoke(PAco1,'Connect',4,3);                invoke(PAco1,'SetAtten',PAattns(3));            else                invoke(PAco1,'Connect',4,3);                invoke(PAco1,'SetAtten',120.0);            end            if config(ear).atten(right),                invoke(PAco1,'Connect',4,1);                invoke(PAco1,'SetAtten',PAattns(1));                invoke(PAco1,'Connect',4,2);                invoke(PAco1,'SetAtten',PAattns(2));                invoke(PAco1,'Connect',4,4);                invoke(PAco1,'SetAtten',PAattns(4));            else                invoke(PAco1,'Connect',4,4);                invoke(PAco1,'SetAtten',120.0);            end            if AnalysisType==6 %In this case X value is time (in ms).... to view on default frequency axes plot as 10/X.                set(h_line2,'XData',10/deltaT(Frun),'YData',-atten);            else                set(h_line2,'XData',freq,'YData',-atten);            end            drawnow;                        invoke(RPco1,'SoftTrg',1);                        switch AnalysisType            case 6                timer(1.1*(maxlength/1000));            otherwise                timer(tspan*20);            end            spk = msdl(2);            time = spk{Channel}(:,2);%Here ths spike times are returned in time                        %Save the spike rate as part of the InhibitData structure            switch AnalysisType            case 1                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin1+(repcount-1)*2*tspan) & time<(RespWin2+(repcount-1)*2*tspan)));%                     fprintf('%2.3f    %2.3f\n',RespWin1+(repcount-1)*2*tspan,RespWin2+(repcount-1)*2*tspan)                end                BRatenow = numspks/(9*(RespWin2-RespWin1));                inhibitdata.spikerate = [inhibitdata.spikerate; [BRatenow atten freq 1]];                %                         inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin3+(repcount-1)*2*tspan) & time<(RespWin4+(repcount-1)*2*tspan)));%                     fprintf('%2.3f    %2.3f\n',RespWin3+(repcount-1)*2*tspan,RespWin4+(repcount-1)*2*tspan)                end                ARatenow = numspks/(9*(RespWin4-RespWin3));                inhibitdata.spikerate = [inhibitdata.spikerate; [ARatenow atten freq 0]];                inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                fprintf('CF+FS_Brate=%2.1f sp/s; CF_Arate=%2.1f sp/s\n',BRatenow,ARatenow);            case 4                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin1+(repcount-1)*2*tspan) & time<(RespWin2+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin1+(repcount-1)*2*tspan,RespWin2+(repcount-1)*2*tspan)                end                ARatenow = numspks/(9*(RespWin2-RespWin1));                inhibitdata.spikerate = [inhibitdata.spikerate; [ARatenow atten freq 0]];                %                         inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin3+(repcount-1)*2*tspan) & time<(RespWin4+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin3+(repcount-1)*2*tspan,RespWin4+(repcount-1)*2*tspan)                end                BRatenow = numspks/(9*(RespWin4-RespWin3));                inhibitdata.spikerate = [inhibitdata.spikerate; [BRatenow atten freq 1]];                inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                fprintf('F_Brate=%2.1f sp/s; M_Arate=%2.1f sp/s\n',BRatenow,ARatenow);            case 5                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin1+(repcount-1)*2*tspan) & time<(RespWin2+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin1+(repcount-1)*2*tspan,RespWin2+(repcount-1)*2*tspan)                end                ARatenow = numspks/(9*(RespWin2-RespWin1));                inhibitdata.spikerate = [inhibitdata.spikerate; [ARatenow atten freq 0]];                %                         inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin3+(repcount-1)*2*tspan) & time<(RespWin4+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin3+(repcount-1)*2*tspan,RespWin4+(repcount-1)*2*tspan)                end                BRatenow = numspks/(9*(RespWin4-RespWin3));                inhibitdata.spikerate = [inhibitdata.spikerate; [BRatenow atten freq 1]];                inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                fprintf('F+M_Brate=%2.1f sp/s; M_Arate=%2.1f sp/s\n',BRatenow,ARatenow);            case 6                ARatenow = length(find(time>(RespWin1+(ToneOn/1000)+(deltaT(Frun)/1000)) & time<(RespWin2+(ToneOn/1000)+(deltaT(Frun)/1000))))/(RespWin2-RespWin1); %This is driven                BRatenow = length(find(time>((maxlength/1000)-(RespWin2-RespWin1)) & time<(maxlength/1000)))/(RespWin2-RespWin1);%This is spont                                inhibitdata.spikerate = [inhibitdata.spikerate; [ARatenow atten deltaT(Frun) 0]];                inhibitdata.spikerate = [inhibitdata.spikerate; [BRatenow atten deltaT(Frun) 1]];                                inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten deltaT(Frun)],numel(time),1)]];            case 2                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin3+(repcount-1)*2*tspan) & time<(RespWin4+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin1+(repcount-1)*2*tspan,RespWin2+(repcount-1)*2*tspan)                end                BRatenow = numspks/(9*(RespWin4-RespWin3));                inhibitdata.spikerate = [inhibitdata.spikerate; [BRatenow atten freq Satten 1]];                %                         inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin1+(repcount-1)*2*tspan) & time<(RespWin2+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin3+(repcount-1)*2*tspan,RespWin4+(repcount-1)*2*tspan)                end                ARatenow = numspks/(9*(RespWin2-RespWin1));                inhibitdata.spikerate = [inhibitdata.spikerate; [ARatenow atten freq Satten 0]];                inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq Satten],numel(time),1)]];                fprintf('CF+FS_Brate=%2.1f sp/s; FS_Arate=%2.1f sp/s\n',BRatenow,ARatenow);               case 3                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin3+(repcount-1)*2*tspan) & time<(RespWin4+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin1+(repcount-1)*2*tspan,RespWin2+(repcount-1)*2*tspan)                end                BRatenow = numspks/(9*(RespWin4-RespWin3));                inhibitdata.spikerate = [inhibitdata.spikerate; [BRatenow atten freq Satten 1]];                %                         inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq],numel(time),1)]];                numspks = 0;                for repcount = 2:10                    numspks = numspks+length(find(time>(RespWin1+(repcount-1)*2*tspan) & time<(RespWin2+(repcount-1)*2*tspan)));                    %                     fprintf('%2.3f    %2.3f\n',RespWin3+(repcount-1)*2*tspan,RespWin4+(repcount-1)*2*tspan)                end                ARatenow = numspks/(9*(RespWin2-RespWin1));                inhibitdata.spikerate = [inhibitdata.spikerate; [ARatenow atten freq Satten 0]];                inhibitdata.spiketimes = [inhibitdata.spiketimes; [time repmat([atten freq Satten],numel(time),1)]];                fprintf('CF_Brate=%2.1f sp/s; FS_Arate=%2.1f sp/s\n',BRatenow,ARatenow);               end            msdl(0);            switch AnalysisType            case {1,6}                idiff = ARatenow - BRatenow; %BRatenow is spike rate in the varied interval            case {4,5}                idiff = BRatenow - ARatenow;            otherwise                idiff = BRatenow - SpikeRateCrit;            end                                    if strcmp(search,'on') & (AnalysisType==2 | AnalysisType==3) & ARatenow>=SpikeRateCrit,                %The case where the suppressor alone (in a growth function)                %brings the unit over the rate criterion. Can't therefore determine threshold for the probe.                %Abort and move to next frequency-level combination.                search = 'off';                new_freq_lev = 1;            else                level_stk(2:9) = level_stk(1:8);                level_stk(1) = atten;                if idiff>=crit,                    atten = atten + 2*attstp;                    if atten <= atthi,                        if (match2==1 & atten==level_stk(3)) | (match2==2 & atten==level_stk(3) & atten==level_stk(6)) | (match2==3 & atten==level_stk(3) & atten==level_stk(6) & atten==level_stk(9)),                            if strcmp(search,'on'), search = 'off'; end                            new_freq_lev = 1;                        end                    else  % M Heinz 05Oct2004: If threshold not found, i.e., sound level cannot be set low enough,                        %%%%  Set to 1 dB beyond highest atten, to indicate Threshold NOT FOUND                        atten=atthi+1;                        if unique(level_stk)==(atthi+1)                            if strcmp(search,'on'), search = 'off'; end                            new_freq_lev = 1;                            atten=atthi;                            NelData.File_Manager.unit.comment=sprintf('Threshold > %.f dB SPL, Stored as %.f dB SPL',atthi,atthi);                            nelerror(NelData.File_Manager.unit.comment);                        end                    end                else                    atten = atten - attstp;                    if atten < attlo, atten = attlo; new_freq_lev = 1; end                end            end            %if new freq-level combination (i.e., threshold found), plot thresh and break            if new_freq_lev == 1,                %save threshold                switch AnalysisType                case {1,4,5}                    inhibitdata.PEST(Frun,:) = [freq atten];                    set(h_line1,'XData',inhibitdata.PEST(1:Frun,1),'YData',-inhibitdata.PEST(1:Frun,2));                case 6 %In this case the X values are actually in ms - to view in frequency axes plot as 10/X - quick fix. M. Sayles 5th November 2014.                    inhibitdata.PEST(Frun,:) = [deltaT(Frun) atten];                    set(h_line1,'XData',10./inhibitdata.PEST(1:Frun,1),'YData',-inhibitdata.PEST(1:Frun,2));                otherwise                    inhibitdata.PEST(Frun,Lrun,:) = [freq atten Satten];                    set(h_line1,'XData',reshape(inhibitdata.PEST(1:Frun,1:Lrun,1),1,numel(inhibitdata.PEST(1:Frun,1:Lrun,1))),...                        'YData',reshape(-inhibitdata.PEST(1:Frun,1:Lrun,2),1,numel(inhibitdata.PEST(1:Frun,1:Lrun,2))));                end                drawnow;                if Frun<frqnum                    if AnalysisType==1 & frqlst(Frun)>=unitCF & frqlst(Frun+1)<unitCF                        atten = atthi;%At the point where the function flips to the low frequency side of CF, flip the starting SPL to max attenuation.                    elseif  AnalysisType==1 & frqlst(Frun+1)<unitCF                        atten =120; %set back to 100 dB atten                    end                 end                set(h_push_start,'Userdata',inhibitdata);                if Lrun==Sattennum,%only advance to a new frequency once all suppressor level conditions completed                    Frun=Frun+1;                end                break;   %% Break out of current frequency-level loop            end            %             end        end  %% Loop to find threshold at current freq (and current Suppressor level in case of growth functions)        if (AnalysisType==2 | AnalysisType==3) & ARatenow>=SpikeRateCrit,            Frun=Frun+1;            break;        end    end %Step through all Suppressor levels at current frequencyend  %Step through all freqsif (isempty(get(h_push_stop,'UserData')))  %% Went through all freqs, i.e., finished on its own    set(h_push_stop,'Userdata','stop');endNelData.inhibit.rc=get(h_push_stop,'Userdata');set(h_push_stop,'Userdata',[]);%% USE NelData.inhibit.rc as a return flag%% Leave Inhibit window open when data is saved ow/ close window!%% Shut down TDT: Needed for all stop conditions (stop, savenquit, restart, abort)for atten_num = 1:4,    invoke(PAco1,'Connect',4,atten_num);    invoke(PAco1,'SetAtten',120.0);endinvoke(RPco1,'Halt');invoke(RPco2,'Halt');set(h_line2,'XData',1e-10,'YData',0);set(h_push_start,'Enable','off');set(h_push_stop,'Enable','off');set(h_push_h_fstep,'Enable','off');set(h_push_d_fstep,'Enable','off');set(h_push_restart,'Enable','off');set(h_push_abort,'Enable','off');set(h_push_saveNquit,'Enable','off');set(h_push_close,'Enable','off');set(h_push_params,'Enable','off');set(h_text3,'buttondownfcn','');set(h_text4,'buttondownfcn','');set(h_text5,'buttondownfcn','');set(h_text6,'buttondownfcn','');%%% Switch on end of data-collection loopswitch NelData.inhibit.rccase 'change_attens/freqs'    def.Low_Atten={PARAMS(5) 'dB' [0 120]};    def.High_Atten={PARAMS(6) 'dB' [0 120]};    def.Low_Freq={PARAMS(1) 'kHz' [0.04 45]};    def.High_Freq={PARAMS(2) 'kHz' [0.04 45]};        dlg_pos=[40.9600   16  122.8800   13.5000];    inp = structdlg(def, 'Change Attenuation/Frequency Limits',struct([]),'on',[],dlg_pos);    PARAMS(5)=inp.Low_Atten;    PARAMS(6)=inp.High_Atten;    PARAMS(1)=inp.Low_Freq;    PARAMS(2)=inp.High_Freq;    clear def inp    eval('update_inhibit_params');		% use function update_tc_params to rewrite the file    NelData.inhibit.rc='restart';    return;case 'abort'    inhibit_curve('close');    return;case 'restart'    return;case 'stop'    set(h_push_restart,'Enable','on');    set(h_push_abort,'Enable','on');    set(h_push_saveNquit,'Enable','on');    set(h_push_params,'Enable','on');        while 1==1       % Wait for user to decide whether to re-start, save, or abort after a stop, or after it finished        pause(.1)        if ~isempty(get(h_push_stop,'Userdata'))            break;        end    end  % End wait for verifying BF    set(h_ax1,'ButtonDownFcn','')    set(h_line1,'ButtonDownFcn','')    NelData.inhibit.rc=get(h_push_stop,'Userdata');    set(h_push_stop,'Userdata',[]);        switch NelData.inhibit.rc    case 'abort'        inhibit_curve('close');        return;    case 'restart'        return;    case 'params'        h_inhibit_params = view_inhibit_params;        uiwait(h_inhibit_params);        inhibit_curve('start');        return;    case 'saveNquit'        set(h_push_restart,'Enable','off');        set(h_push_abort,'Enable','off');        set(h_push_saveNquit,'Enable','off');        set(h_push_params,'Enable','off');                dlg_pos=[40.9600   1.5  122.8800   15.5000];                new_unit(NelData.File_Manager.unit.No,[],NelData.inhibit,'on',dlg_pos,1);                comment=NelData.File_Manager.unit.comment;        [filename, shortfname] = current_data_file('inhibit');        make_inhibit_text_file;                update_inhibit_params;        filename = current_data_file('inhibit');        set(h_push_close,'Enable','on');        uiresume;        return;    endend